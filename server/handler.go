package server

import (
	"fmt"
	"os"
	"time"

	"../commons"
	"../utils"

	"github.com/golang/protobuf/proto"
	"github.com/gorilla/websocket"
	ecdh "github.com/wsddn/go-ecdh"
)

func handleMessage(conn *websocket.Conn, message []byte, code uint32, state *utils.State) {
	switch code {
	case commons.S_JOIN_RESPONSE:
		response := &commons.RegisterResponse{}
		err := proto.Unmarshal(message, response)
		checkError(err)
		handleJoinResponse(response, state)
	case commons.S_START_DICEMIX:
		response := &commons.DiceMixResponse{}
		err := proto.Unmarshal(message, response)
		checkError(err)
		handleStartDicemix(conn, response, state)
	case commons.S_KEY_EXCHANGE:
		response := &commons.DiceMixResponse{}
		err := proto.Unmarshal(message, response)
		checkError(err)
		handleKeyExchangeResponse(conn, response, state)
	case commons.S_EXP_DC_VECTOR:
		response := &commons.DCExpResponse{}
		err := proto.Unmarshal(message, response)
		checkError(err)
		handleDCExpResponse(conn, response, state)
	case commons.S_SIMPLE_DC_VECTOR:
		response := &commons.DiceMixResponse{}
		err := proto.Unmarshal(message, response)
		checkError(err)
		handleDCSimpleResponse(conn, response, state)
	}
}

func handleJoinResponse(response *commons.RegisterResponse, state *utils.State) {
	if response.Err != "" {
		fmt.Fprintf(os.Stderr, "error: %v\n", response.Err)
		os.Exit(1)
	}

	state.MyID = response.Id

	fmt.Printf("%s\n", response.Message)
	fmt.Printf("MY ID - %v\n", state.MyID)
}

func handleStartDicemix(conn *websocket.Conn, response *commons.DiceMixResponse, state *utils.State) {
	if response.Err != "" {
		fmt.Fprintf(os.Stderr, "error: %v\n", response.Err)
		os.Exit(1)
	}

	// increment the run
	state.Run++
	state.Peers = make([]utils.Peers, len(response.Peers)-1)
	i := 0

	// store peers ID's
	for _, peer := range response.Peers {
		if peer.Id != state.MyID {
			state.Peers[i].ID = peer.Id
			i++
		}
	}

	// generates NIKE KeyPair for current run
	iNike.GenerateKeys(state)

	// KeyExchange
	// broadcast our NIKE PublicKey with our peers
	ecdh := ecdh.NewCurve25519ECDH()
	keyExchangeRequest, err := proto.Marshal(&commons.KeyExchangeRequest{
		Code:      commons.C_KEY_EXCHANGE,
		Id:        state.MyID,
		PublicKey: ecdh.Marshal(state.Kepk),
		NumMsgs:   state.MyMsgCount,
		Timestamp: timestamp(),
	})

	broadcast(conn, keyExchangeRequest, err)
}

func handleKeyExchangeResponse(conn *websocket.Conn, response *commons.DiceMixResponse, state *utils.State) {
	if response.Err != "" {
		fmt.Fprintf(os.Stderr, "error: %v\n", response.Err)
		os.Exit(1)
	}

	// store peers PublicKey and NumMsgs
	for i := 0; i < len(response.Peers); i++ {
		for j := 0; j < len(state.Peers); j++ {
			if response.Peers[i].Id == state.Peers[j].ID {
				state.Peers[j].PubKey = response.Peers[i].PublicKey
				state.Peers[j].NumMsgs = response.Peers[i].NumMsgs
				break
			}
		}
	}

	// derive shared keys with peers
	iNike.DeriveSharedKeys(state)

	// generate DC Exponential Vector
	iDcNet.DeriveMyDCVector(state)

	// DC EXP
	// broadcast our DC-EXP vector with peers
	dcExpRequest, err := proto.Marshal(&commons.DCExpRequest{
		Code:        commons.C_EXP_DC_VECTOR,
		Id:          state.MyID,
		DCExpVector: state.MyDC,
		Timestamp:   timestamp(),
	})

	broadcast(conn, dcExpRequest, err)
}

func handleDCExpResponse(conn *websocket.Conn, response *commons.DCExpResponse, state *utils.State) {
	if response.Err != "" {
		fmt.Fprintf(os.Stderr, "error: %v\n", response.Err)
		os.Exit(1)
	}

	// store roots (message hashes) generated by server
	state.AllMsgHashes = response.Roots

	// run a SIMPLE DC NET
	iDcNet.RunDCSimple(state)

	// broadcast our DC NET Vector
	dcSimpleRequest, err := proto.Marshal(&commons.DCSimpleRequest{
		Code:           commons.C_SIMPLE_DC_VECTOR,
		Id:             state.MyID,
		DCSimpleVector: state.DCSimpleVector,
		Timestamp:      timestamp(),
	})

	broadcast(conn, dcSimpleRequest, err)
}

func handleDCSimpleResponse(conn *websocket.Conn, response *commons.DiceMixResponse, state *utils.State) {
	if response.Err != "" {
		fmt.Fprintf(os.Stderr, "error: %v\n", response.Err)
		os.Exit(1)
	}

	// store other peers DC Simple Vectors
	for i := 0; i < len(response.Peers); i++ {
		for j := 0; j < len(state.Peers); j++ {
			if response.Peers[i].Id == state.Peers[j].ID {
				state.Peers[j].DCSimpleVector = response.Peers[i].DCSimpleVector
				break
			}
		}
	}

	// finally resolves DC Net Vectors to obtain messages
	// should contain all honest peers messages in absence of malicious peers
	iDcNet.ResolveDCNet(state)
}

// send request to server
func broadcast(conn *websocket.Conn, request []byte, err error) {
	checkError(err)
	err = conn.WriteMessage(websocket.TextMessage, request)
	checkError(err)
}

func timestamp() string {
	return time.Now().String()
}
